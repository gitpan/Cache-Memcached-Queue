.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cache::Memcached::Queue 3"
.TH Cache::Memcached::Queue 3 "2012-06-25" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cache::memcached::Queue \- Create queues and save them on memcached!
.SH "VERSION"
.IX Header "VERSION"
Version 0.0.1 alpha
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This works by taking advantage of Memcached infrastructure. In other words, the 'keys' 
will be strings that are names of indexes for some basic values that are sufficient to
represent a queue structure. This basic values are: first, last, size and max_enq.
.PP
In order to have multiples queues in the same Memcached server, a prefix are added 
to every index on keys of Memcached. So, every key in memcached have the following 
struct on his name: <\s-1PREFIX\s0>_<\s-1ID\s0>_<\s-1INDEX_NUMBER\s0 \s-1OR\s0 \s-1NAME\s0>
.IP " \s-1PREFIX\s0 \- This is defined by the 'id_prefix' attribute. The default value is '\s-1CMQID_\s0'" 4
.IX Item " PREFIX - This is defined by the 'id_prefix' attribute. The default value is 'CMQID_'"
.PD 0
.IP " \s-1ID\s0 \- This is defined by the 'id' attribute." 4
.IX Item " ID - This is defined by the 'id' attribute."
.IP " \s-1INDEX_NUMBER\s0 \s-1OR\s0 \s-1NAME\s0 \- If some data is a item in the queue, so this must be a sequential number, for example: '\s-1CMQID_1_1\s0' This can be the first element from queue with id 1. If some data in the queue is a pointer, this pointer must be named, for example: 'CMQID_1_first' This is the pointer to the first element in queue." 4
.IX Item " INDEX_NUMBER OR NAME - If some data is a item in the queue, so this must be a sequential number, for example: 'CMQID_1_1' This can be the first element from queue with id 1. If some data in the queue is a pointer, this pointer must be named, for example: 'CMQID_1_first' This is the pointer to the first element in queue."
.PD
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module implements a simple scheme of a Queue.
.PP
.Vb 1
\&    use Cache::memcached::Queue;
\&
\&    my $q = Cache::memcached::Queue\->new( name => \*(Aqfoo\*(Aq, #this is mandatory
\&                                                max_enq => 10,
\&                                                config_file => \*(Aqpath_to_config/configfile.cfg\*(Aq,
\&                                                id => 1,
\&                                        )\->init;
\&                        
\&                                        
\&    $q\->enq(\*(Aqduke\*(Aq); #enqueue \*(Aqduke\*(Aq. 
\&
\&    $q\->enq(\*(Aqnuken\*(Aq); #enqueue \*(Aqnuke\*(Aq and this never expires on memcached 
\&
\&    $q\->show; #show all items from queue. In this case: \*(Aqduke\*(Aq(first element) and \*(Aqnuken\*(Aq(last element).
\&
\&    $q\->deq; #deqeue \*(Aqduke\*(Aq. 
\&
\&    $q\->show; #show all items from queue. In this case: \*(Aqnuke\*(Aq(first and last element from queue).
.Ve
.PP
or
.PP
.Vb 4
\&    $q\->enq({ qid => 1, #queue id = 1
\&                value => \*(AqDuke\*(Aq},);
\&    $q\->enq({ qid => 2, #queue id = 2
\&                value => \*(AqNuken\*(Aq},);
\&
\&    $q\->deq({qid => 1}); #brings \*(AqDuke\*(Aq
\&
\&    $q\->deq({qid => 1}); #brings \*(Aqqueue empty\*(Aq
\&
\&    $q\->deq({qid => 2}); #brings \*(AqNuken\*(Aq
.Ve
.SS "\fIinit()\fP"
.IX Subsection "init()"
Initialize object attributes and check attributes problems. If all is ok, returns the reference to object.
Otherwise returns undef and trows an exception
.SS "\fIload()\fP"
.IX Subsection "load()"
Try to load the queue pointers from Memcached. If works, will return true. Otherwise 
will return false.
.PP
Try to make a 'enqueue' operation. That means tha 'last' index pointer will be readjusted
to the next index. So the value can be recorded on Memcached.
.PP
The parameters are validated, and the valid parameters are:
.IP " value \- A value that presupposes that you want to save" 4
.IX Item " value - A value that presupposes that you want to save"
.PD 0
.IP " serialize \- If you need the value to be serialized, you must set serialized to \fItrue\fR\|(1). \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1YET\s0." 4
.IX Item " serialize - If you need the value to be serialized, you must set serialized to true. NOT IMPLEMENTED YET."
.PD
.PP
Example: \f(CW$en\fRq({value => 'some_value'});
.PP
Example2: \f(CW$en\fRq({value => \f(CW$some_object_or_structure\fR,
                serialize => 1, });
.PP
If this work, the method will return true. Otherwise, will return false.
.SS "\fIdeq()\fP"
.IX Subsection "deq()"
Try to make a 'dequeue' operation on Queue. That means the first value
of queue will be removed from queue, and the first index pointer from queue will
be moved to the next index. If works, returns the 'dequeued' 
value, otherwise returns undef.
.SS "\fIshow()\fP"
.IX Subsection "show()"
Try to show the content of queue(the data). This is made finding the 'first' 
and 'last' pointers, extracting the sequential index, and interate the queue 
with this indexes, making a 'get' operation from Memcached. If the value
exists, it will be showed. If not, a exception will be thrown .
.SS "\fIcleanup()\fP"
.IX Subsection "cleanup()"
Dequeue everything!
.SS "save($parameters)"
.IX Subsection "save($parameters)"
Try to save queue pointers on Memcached. The parameters came on arrayref, when
each position of arrayref is a name of attribute that must be saved. This parameters 
are validated and then saved on memcached.
.PP
That makes the enqueuing process faster than save all parameters everytime, because
the input operations on Memcached are reduced.
.PP
Ex: \f(CW$q\fR\->save(['name','first']);
.PP
The valid parameters are:
.IP " name \- Is the name of Queue;" 4
.IX Item " name - Is the name of Queue;"
.PD 0
.IP " first \- Is the first index of the key. Not the value, but the name of index;" 4
.IX Item " first - Is the first index of the key. Not the value, but the name of index;"
.IP " last \- As the same way, this is the last index of the queue." 4
.IX Item " last - As the same way, this is the last index of the queue."
.PD
.PP
If everything work well the method returns true. Otherwise returns false.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andre Garcia Carneiro, \f(CW\*(C`<bang at cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-cache\-memcached\-queue at rt.cpan.org\*(C'\fR, or through
the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Cache\-memcached\-Queue <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Cache-memcached-Queue>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Cache::memcached::Queue
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Cache\-memcached\-Queue <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Cache-memcached-Queue>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/Cache\-memcached\-Queue <http://annocpan.org/dist/Cache-memcached-Queue>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/Cache\-memcached\-Queue <http://cpanratings.perl.org/d/Cache-memcached-Queue>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/Cache\-memcached\-Queue/ <http://search.cpan.org/dist/Cache-memcached-Queue/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2011 Andre Garcia Carneiro.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 196:" 4
.IX Item "Around line 196:"
Unknown directive: =head
